#!/usr/bin/env python3
"""
Building Production Information Generator for La Serenissima.

This script updates building JSON files with production information generated by Claude.
"""

import os
import sys
import logging
import json
import time
import re
from typing import Dict, Any, Optional
import requests
from dotenv import load_dotenv

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger("building_production_generator")

# Load environment variables
load_dotenv()

def generate_production_info(building_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """Generate production information for a building using Claude API.
    
    Args:
        building_data: The building data dictionary
        
    Returns:
        A dictionary containing the production information, or None if generation failed
    """
    building_name = building_data.get("name", "Unknown Building")
    log.info(f"Generating production information for: {building_name}")
    
    # Get Claude API key from environment
    claude_api_key = os.environ.get('CLAUDE_API_KEY')
    if not claude_api_key:
        log.error("CLAUDE_API_KEY environment variable is not set")
        return None
    
    try:
        # Create a system prompt for Claude
        system_prompt = """You are an expert game designer helping to create a historically accurate economic simulation game set in Renaissance Venice (1400-1600) called La Serenissima.

TASK:
Create a detailed production information JSON object for a building in the game.

The production information should include:
1. Arti - an array of recipes that transform input resources into output resources
2. Total storage capacity
3. List of resources the building can store
4. List of resources the building can sell

Use ONLY the following resources:
banking_services
blackmail_evidence
books
bread
bricks
building_materials
clay
cut_stone
disguise_materials
dyed_textiles
dyestuffs
fine_glassware
fish
flax
flour
forgery_tools
fuel
glass
gold
gold_leaf
gondola
grain
hemp
iron
iron_fittings
iron_ore
jewelry
limestone
luxury_silk_garments
maps
marble
merchant_galley
molten_glass
mortar
sand
olives
olive_oil
paper
pine_resin
pitch
poison_components
porter_equipment
prepared_silk
preserved_fish
processed_iron
rags
raw_silk
rope
sailcloth
salt
sand
ship_components
silk_fabric
small_boats
smuggler_maps
soap
soda_ash
spiced_wine
stone
timber
tools
venetian_lace
war_galley
water
weapons
wine

Production Tier Time
(Tier 1) 5-30 minutes Simple food, basic cloth, common tools
(Tier 2) 15-60 minutes Quality cloth, leather goods, standard glassware
(Tier 3) 1-4 hours Fine textiles, quality furniture, intricate glassware
(Tier 4) 3-12 hours Luxury silk, master-crafted glass, jewelry
(Tier 5) 1-7 days Ships, elaborate art pieces, major construction
"""

        # Create a citizen prompt with building details and expected format
        citizen_prompt = f"""I need production information for a building called "{building_name}".

Here's what I know about this building:
Category: {building_data.get('category', 'Unknown')}
SubCategory: {building_data.get('subCategory', 'Unknown')}
Short Description: {building_data.get('shortDescription', 'No description available')}
Full Description: {building_data.get('fullDescription', 'No description available')}

Please think it through then create a JSON object with the following structure:

```json
{{
  "Arti": [
    {{
      "inputs": {{
        "ResourceName1": 1, // try to keep the ratios simple
        "ResourceName2": 2 // Keep the production lines simple (3 inputs max)
      }},
      "outputs": {{
        "OutputResourceName1": 1 // should be 1
      }},
      "craftMinutes": 20 // in minutes
    }},
    {{
      "inputs": {{
        "ResourceName3": 1 // comes from the list only
      }},
      "outputs": {{
        "OutputResourceName2": 1 // comes from the list only
      }},
      "craftMinutes": 20 
    }}
  ],
  "storageCapacity": 100,
  "stores": [
    "ResourceName1", // comes from the list only
    "ResourceName2", // comes from the list only
    "OutputResourceName1", // comes from the list only
    "OutputResourceName2", // comes from the list only
    "OtherStorableResource" // for input/storage buildings
  ],
  "sells": [
    "OutputResourceName1", // comes from the list only
    "OutputResourceName2" // comes from the list only
    "OtherSellableResource"// for commerces
  ]
}}
```

The numbers in inputs and outputs represent quantities needed/produced per craft.
The craftMinutes is in minutes.
Use resource IDs in snake_case (like "olive_oil" not "Olive Oil").
Make sure the resources are ONLY from the provided list (important!).
If it does not make sense for the building to store/transform/sell resources, write an empty JSON
"""
        
        # Call Claude API
        response = requests.post(
            "https://api.anthropic.com/v1/messages",
            headers={
                "Content-Type": "application/json",
                "x-api-key": claude_api_key,
                "anthropic-version": "2023-06-01"
            },
            json={
                "model": "claude-sonnet-4-20250514",
                "max_tokens": 1000,
                "system": system_prompt,
                "messages": [
                    {
                        "role": "citizen",
                        "content": citizen_prompt
                    }
                ]
            }
        )
        
        if response.status_code != 200:
            log.error(f"Error from Claude API: {response.status_code} {response.text}")
            return None
        
        # Extract the JSON from Claude's response
        content = response.json()["content"][0]["text"]
        
        # Log the full response from Claude
        log.info(f"Claude's raw response for {building_name}:\n{content}")
        
        # Find the JSON object in the response
        json_match = re.search(r'```json\s*({[\s\S]*?})\s*```', content)
        
        # If that doesn't find a match, try to find just a JSON object:
        if not json_match:
            json_match = re.search(r'({[\s\S]*?})', content)
            
        if not json_match:
            log.error(f"Could not extract JSON from Claude response: {content}")
            return None

        # Clean the extracted JSON string to remove any trailing text
        json_str = json_match.group(1).strip()
        # Find the last closing brace
        last_brace_index = json_str.rindex('}')
        json_str = json_str[:last_brace_index+1]
        
        # Remove any comments (// style)
        json_str = re.sub(r'//.*?(\n|$)', '', json_str)

        try:
            production_info = json.loads(json_str)
            log.info(f"Successfully generated production information for {building_name}")
            return production_info
        except json.JSONDecodeError as e:
            # Try a more aggressive approach to clean the JSON if first attempt fails
            try:
                # Remove all comments and normalize the JSON
                clean_json_str = re.sub(r'//.*?(\n|$)', '', json_str)
                # Remove any trailing commas before closing brackets or braces
                clean_json_str = re.sub(r',(\s*[\]}])', r'\1', clean_json_str)
                production_info = json.loads(clean_json_str)
                log.info(f"Successfully parsed JSON after cleaning")
                return production_info
            except json.JSONDecodeError as e2:
                log.error(f"Error parsing JSON even after cleaning: {e2}")
                log.error(f"JSON string: {json_str}")
                return None
    except Exception as e:
        log.error(f"Error generating production information: {e}")
        return None

def update_building_file(file_path: str) -> bool:
    """Update a building file with generated production information.
    
    Args:
        file_path: Path to the building JSON file
        
    Returns:
        True if successful, False otherwise
    """
    try:
        # Read the building file
        with open(file_path, 'r', encoding='utf-8') as f:
            building_data = json.load(f)
        
        # Generate production information
        production_info = generate_production_info(building_data)
        if not production_info:
            return False
        
        # Update the building data
        building_data['productionInformation'] = production_info
        
        # Write the updated building data back to the file
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(building_data, f, indent=2)
        
        log.info(f"Updated {file_path} with new production information")
        return True
    except Exception as e:
        log.error(f"Error updating building file {file_path}: {e}")
        return False

def process_all_buildings(buildings_dir: str) -> None:
    """Process all building files in the specified directory.
    
    Args:
        buildings_dir: Path to the directory containing building JSON files
    """
    # Ensure the directory exists
    if not os.path.exists(buildings_dir):
        log.error(f"Directory {buildings_dir} does not exist")
        return
    
    # Get all JSON files in the directory
    building_files = [
        os.path.join(buildings_dir, f) for f in os.listdir(buildings_dir)
        if f.endswith('.json')
    ]
    
    log.info(f"Found {len(building_files)} building files to process")
    
    success_count = 0
    for file_path in building_files:
        log.info(f"Processing {os.path.basename(file_path)}")
        if update_building_file(file_path):
            success_count += 1
        
        # Add a small delay to avoid rate limiting
        time.sleep(2)
    
    log.info(f"Successfully updated {success_count} out of {len(building_files)} building files")

if __name__ == "__main__":
    # Get buildings directory from command line or use default
    buildings_dir = sys.argv[1] if len(sys.argv) > 1 else os.path.join(os.getcwd(), 'data', 'buildings')
    
    log.info(f"Starting production information generation for buildings in {buildings_dir}")
    process_all_buildings(buildings_dir)
    log.info("Completed production information generation")
