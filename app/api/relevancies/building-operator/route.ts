import { NextRequest, NextResponse } from 'next/server';
import { relevancyService } from '@/lib/services/RelevancyService';
import { saveRelevancies } from '@/lib/utils/relevancyUtils';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { Citizen } = body; 
    const username = Citizen; 

    if (!username) {
      return NextResponse.json(
        { error: 'Username (Citizen) is required' },
        { status: 400 }
      );
    }

    // Fetch all citizens and lands for context if saveRelevancies needs them (it does)
    const citizensResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/citizens`);
    const citizensData = await citizensResponse.json();
    const allCitizens = citizensData.citizens || [];
    
    const allLands = await relevancyService.fetchLands(); // saveRelevancies needs allLands for 'land' type, but not strictly for 'building' type if notes are self-contained. Good to have for consistency.

    // Calculate building-operator relevancies. This returns RelevancyScore[]
    // The service generates pairs if the initial 'username' is involved.
    const allGeneratedRelevancies = await relevancyService.calculateBuildingOperatorRelevancy(username);
    console.log(`[API building-operator POST for initial user ${username}] Total relevancy objects generated by service: ${allGeneratedRelevancies.length}`);

    // Group relevancies by who they are relevant to
    const relevanciesByCitizen: Record<string, Record<string, any>> = {};
    allGeneratedRelevancies.forEach(relevancy => {
      const relevantToField = relevancy.relevantToCitizen;
      if (!relevantToField) {
        console.warn('[API building-operator POST] Skipping relevancy with no relevantToCitizen:', relevancy);
        return;
      }
      // Ensure relevantTo is a string for use as a key
      const relevantToKey = Array.isArray(relevantToField) ? relevantToField.join(',') : String(relevantToField);

      if (!relevanciesByCitizen[relevantToKey]) {
        relevanciesByCitizen[relevantToKey] = {};
      }
      // Create a unique key for the relevancy: buildingId_type
      const relevancyKey = `${relevancy.asset}_${relevancy.type}`;
      relevanciesByCitizen[relevantToKey][relevancyKey] = relevancy;
    });

    let totalSavedCount = 0;
    let saveSucceededForAll = true;

    for (const citizenToSaveFor of Object.keys(relevanciesByCitizen)) {
      console.log(`[API building-operator POST] Saving ${Object.keys(relevanciesByCitizen[citizenToSaveFor]).length} relevancies for citizen: ${citizenToSaveFor}`);
      try {
        // saveRelevancies expects allLands and allCitizens for context, even if not used for all types
        const count = await saveRelevancies(citizenToSaveFor, relevanciesByCitizen[citizenToSaveFor], allLands, allCitizens);
        totalSavedCount += count;
        console.log(`[API building-operator POST] Successfully saved ${count} relevancies for ${citizenToSaveFor}`);
      } catch (error) {
        console.error(`[API building-operator POST] Error saving relevancies for ${citizenToSaveFor}:`, error);
        saveSucceededForAll = false;
      }
    }
    
    // For the API response, filter out relevancies specifically for the originally requested 'username'
    const relevanciesForRequestingUser = allGeneratedRelevancies.filter(r => r.relevantToCitizen === username);
    const simpleScoresForRequestingUser: Record<string, number> = {};
    const detailedRelevancyForRequestingUser: Record<string, any> = {};

    relevanciesForRequestingUser.forEach(relevancy => {
      const key = `${relevancy.asset}_${relevancy.type}`;
      simpleScoresForRequestingUser[key] = relevancy.score;
      detailedRelevancyForRequestingUser[key] = relevancy;
    });

    return NextResponse.json({
      success: saveSucceededForAll,
      username: username,
      relevancyScores: simpleScoresForRequestingUser,
      detailedRelevancy: detailedRelevancyForRequestingUser,
      saved: saveSucceededForAll,
      relevanciesSavedCount: totalSavedCount
    });
    
  } catch (error) {
    console.error('Error calculating and saving building operator relevancies:', error);
    return NextResponse.json(
      { error: 'Failed to calculate building operator relevancies', details: error.message },
      { status: 500 }
    );
  }
}
