import { NextRequest, NextResponse } from 'next/server';
import { relevancyService } from '@/lib/services/RelevancyService';
import { saveRelevancies } from '@/lib/utils/relevancyUtils';

export async function GET(request: NextRequest) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url);
    const username = searchParams.get('username') || searchParams.get('ai'); // Support both parameters
    
    if (!username) {
      return NextResponse.json({ error: 'Username is required' }, { status: 400 });
    }
    
    // Calculate building-land ownership relevancy
    const relevancyScores = await relevancyService.calculateBuildingLandOwnershipRelevancy(username);
    console.log(`[API building-ownership POST for ${username}] Calculated relevancyScores:`, JSON.stringify(relevancyScores, null, 2));
    
    // Format the response
    const simpleScores: Record<string, number> = {};
    Object.entries(relevancyScores).forEach(([id, data]) => {
      simpleScores[id] = data.score;
    });
    
    return NextResponse.json({
      success: true,
      username,
      relevancyScores: simpleScores,
      detailedRelevancy: relevancyScores
    });
    
  } catch (error) {
    console.error('Error calculating building ownership relevancies:', error);
    return NextResponse.json(
      { error: 'Failed to calculate building ownership relevancies', details: error.message },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    // Get the username from the request body
    const body = await request.json();
    const { Citizen } = body; // Changed from aiUsername
    const username = Citizen; // Use the new parameter
    
    if (!username) {
      return NextResponse.json(
        { error: 'Username is required' },
        { status: 400 }
      );
    }
    
    // Fetch all citizens for relevancy context (e.g. finding names)
    const citizensResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/citizens`);
    const citizensData = await citizensResponse.json();
    const allCitizens = citizensData.citizens || [];
    
    // Fetch all lands
    const allLands = await relevancyService.fetchLands();
    
    // Calculate building-land ownership relevancy. This now returns RelevancyScore[]
    const allGeneratedRelevancies = await relevancyService.calculateBuildingLandOwnershipRelevancy(username);
    console.log(`[API building-ownership POST for initial user ${username}] Total relevancy objects generated by service: ${allGeneratedRelevancies.length}`);

    // Group relevancies by who they are relevant to
    const relevanciesByCitizen: Record<string, Record<string, any>> = {};
    allGeneratedRelevancies.forEach(relevancy => {
      const relevantToField = relevancy.relevantToCitizen;
      if (!relevantToField) {
        console.warn('[API building-ownership POST] Skipping relevancy with no relevantToCitizen:', relevancy);
        return;
      }
      // Ensure relevantTo is a string for use as a key
      const relevantToKey = Array.isArray(relevantToField) ? relevantToField.join(',') : String(relevantToField);

      if (!relevanciesByCitizen[relevantToKey]) {
        relevanciesByCitizen[relevantToKey] = {};
      }
      // Create a unique key for the relevancy within that citizen's list
      // Using asset (buildingId) and closestLandId (landId) should be unique for this context
      const relevancyKey = `${relevancy.asset}_${relevancy.closestLandId}_${relevancy.type}`;
      relevanciesByCitizen[relevantToKey][relevancyKey] = relevancy;
    });

    let totalSavedCount = 0;
    let saveSucceededForAll = true;

    for (const citizenToSaveFor of Object.keys(relevanciesByCitizen)) {
      console.log(`[API building-ownership POST] Saving ${Object.keys(relevanciesByCitizen[citizenToSaveFor]).length} relevancies for citizen: ${citizenToSaveFor}`);
      try {
        const count = await saveRelevancies(citizenToSaveFor, relevanciesByCitizen[citizenToSaveFor], allLands, allCitizens);
        totalSavedCount += count;
        console.log(`[API building-ownership POST] Successfully saved ${count} relevancies for ${citizenToSaveFor}`);
      } catch (error) {
        console.error(`[API building-ownership POST] Error saving relevancies for ${citizenToSaveFor}:`, error);
        saveSucceededForAll = false;
        // Continue to try saving for other citizens
      }
    }
    
    // For the API response, filter out relevancies specifically for the originally requested 'username'
    const relevanciesForRequestingUser = allGeneratedRelevancies.filter(r => r.relevantToCitizen === username);
    const simpleScoresForRequestingUser: Record<string, number> = {};
    const detailedRelevancyForRequestingUser: Record<string, any> = {};

    relevanciesForRequestingUser.forEach(relevancy => {
      const key = `${relevancy.asset}_${relevancy.closestLandId}_${relevancy.type}`;
      simpleScoresForRequestingUser[key] = relevancy.score;
      detailedRelevancyForRequestingUser[key] = relevancy;
    });

    return NextResponse.json({
      success: saveSucceededForAll,
      username: username, // The user for whom the calculation was initiated
      relevancyScores: simpleScoresForRequestingUser, // Scores relevant to the initial user
      detailedRelevancy: detailedRelevancyForRequestingUser, // Detailed relevancies for the initial user
      saved: saveSucceededForAll, // Overall save status
      relevanciesSavedCount: totalSavedCount // Total records saved across all affected citizens
    });
    
  } catch (error) {
    console.error('Error calculating and saving building ownership relevancies:', error);
    return NextResponse.json(
      { error: 'Failed to calculate building ownership relevancies', details: error.message },
      { status: 500 }
    );
  }
}
